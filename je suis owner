


# produit Client supposé défini
# Segementation supposée effectuée
import numpy as np
import scipy.stats as stats
import math
Nb_States = 24
Stock_beg = 20
def Demand(time, price):
    return Stock_beg*math.exp(-price)*math.exp(-(time-12)**2/24)


# alet Demand centrée en demand plus haut

def Prob(i,j, prix, k,l):
    var_demande = 3
    if (k != i + 1 or j< l):
        return 0
    demande = Demand(i, prix)
    proba = stats.norm.cdf(l+1,demande, var_demande) - stats.norm.cdf(l,demande, var_demande)
    return proba
    # coder une densité ayant son maximum en Demand
    # retourner la probabilité


def reward(i,j,prix,k,l):
    return prix*(j-l) -5


def Esp(i,j, tab_V, prix):

    P = np.array([Prob(i,j, prix, i+1,l) for l in range(Stock_beg)])
    V_r = np.array([tab_V[i + 1][j] + reward(i,j, prix, i+1,l) for l in range(Stock_beg)])
    return np.dot(P, V_r)


def ChooseAction(i,j, tab_V, liste_Prix):
    maximum = -np.inf
    argmax = 0
    for price in liste_Prix:
        esp = Esp(i,j,tab_V,price)
        if esp>maximum:
            maximum = esp
            argmax = price
    return maximum,argmax

def update_MDP(tab_V, liste_Prix):
    tab_int = np.zeros((Nb_States,Stock_beg))
    Vmax, prix = ChooseAction(0,Stock_beg-1,tab_V,liste_Prix)
    tab_int[0][Stock_beg-1] = Vmax
    for i in range(1,Nb_States-1):
        for j in range(Stock_beg):
            Vmax, prix = ChooseAction(i,j,tab_V, liste_Prix)
            tab_int[i][j] = Vmax
    return tab_int



def main():

    pmax = 20
    pmin = 10
    liste_Prix = []
    # Creation action par pas de k
    k = 10
    pas = (pmax - pmin) / (k - 1)
    for i in range(k):
        liste_Prix = np.append(liste_Prix, (pmin + i * pas))
    # creation etats de 20h à 23h50 par pas de 10

    tab_V = np.random.rand(Nb_States, Stock_beg)*0.10


    NB_ITE = 10
    for i in range(NB_ITE):
        tab_V = update_MDP(tab_V, liste_Prix)
        print(i)
    print(tab_V)
if __name__ == "__main__":
    # execute only if run as a script
    main()
