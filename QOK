#produit Client supposé défini 
#Segementation supposée effectuée 
import numpy as np  
class Action : 
	#constructeur

	def __init__(self , prix):
		self.prix = prix


#On peut définir des actions de dimunition prix 
class Etat :
	#constructeur
    def __init__(self ,time , stock ):
        self.time = 0
        self.stock = 0



def Demand(time , price):
	
	return beta_t * time_quant + beta_p + price 

#alet Demand centrée en demand plus haut 

def Prob(eta1 , action , etat2):
			if(etat2.time != etat1.time+1 or etat1.stock < etat2.stock ) :
				return 0
			Demand = Demand(etat1.time , action.prix)
			#coder une densité ayant son maximum en Demand 
			#retourner la probabilité 
			return 1/3

def Esp(etat , tab_V , action):
	i = etat.time
	P = np.array([ prob(etat , State(i + 1 , j) , action) for j in range(Stock_beg) ])
	V_r = np.array([ tab_V[i+1][j] + reward(State(j), action , ) for j in range(Stock_beg) ])
	return sum(np.dot(P , np.transpose(V_r)))

def argmax(f ,etat, tab_V , ensemble):
	result=ensemble[0] 
	for i in ensemble : 
		if (f(etat , tab_V , result)<f(etat , tab_V , i)):
			result = i
	return result 

def ChooseAction(etat , tab_V):
	return argmax(Esp , etat , tab_V , Table_actions)


def main():
	theta1 = 1/2
	theta2 = 1/2
	Nb_states = 24
	Stock_beg = 100
	pmax = 20 
	pmin = 10
	Table_actions =[]
	#Creation action par pas de k
	k = 10 
	pas = (pmax - pmin)/(k - 1)
	for i in range(k):
		Table_actions.append(Action(pmin + i*pas))
	Table_actions = np.array (Table_actions )
	#creation etats de 20h à 23h50 par pas de 10
	
	tab_V = np.array([])
	tab0 = [0 for i in range(Stock_beg - 1)]
	tab_d = tab0
	tab_d.append(0)
	tab0.append(1)
	tab_V = np.zeros((Nb_states ,Stock_beg ))
	tab_V[0][Stock_beg - 1] = 1
	Print_tabAc(Table_actions)
	print(tab_V)


def Print_tabAc(Table_actions):
	print("-- " , end="")
	for i in Table_actions:
		print(i.prix , " -- ",end="")
	print()
main()
