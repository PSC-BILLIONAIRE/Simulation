#produit Client supposé défini 
#Segementation supposé effectuée 
#le but est de maximiser la fonction Q  
gamma = 0.5 # facteur d'actualisation entre 0 et 1
alpha = 0.5 #facteur d'apprentissage entre 0 et 1
Class Etat :
	#constructeur 
	def __init__(self):
		self.heure = 0 #heure en minutes
		self.distance = 0 #distance en km 
		self.temperature = 0 #température en dégré celcius
		
Class Action : 
	def __init__(self):
		self.Prix=0#table de Prix chaque 10mins	
Class Etat_Action : 
	def __init__(self):
		self.etat = Etat 
		self.action = Action 
		
Class Politique : 
	
	def __init__(self): 
		self.TAction = [] #table de (Etat , Action ) 
yet = False 
def Q(etat , action):  #définition fonction Q par défaut 
	try:
		return (1-alpha)*Q(etat , action) + alpha * (récompense (etat , action) + gamma * max( Q( etat_suivant(etat)  , action))
	except:
		return ( action.Prix - Prix_defaut ) 
	
	

def récompense(etat , action):
	
	return récompense #récompense=revenu du vendeur - stock_restant*prix

#le but est donc de trouver la politique qui maximise la fonction Executer  

def act_opt(etat): 
	max = action0 
	return (l'acton avec la plus grande Récompense(sur de long terme))
