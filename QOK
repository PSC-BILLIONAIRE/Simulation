#produit Client supposé défini 
#Segementation supposée effectuée 
import numpy as np  
class Action : 
	#constructeur

	def __init__(self , prix):
		self.prix = prix


#On peut définir des actions de dimunition prix 
class Etat :
	#constructeur
    def __init__(self ,time , stock ):
        self.time = 0
        self.stock = 0



def Demand(time , price):
	
	return beta_t * time_quant + beta_p + price 

#alet Demand centrée en demand plus haut 

def Prob(eta1 , action , etat2):
			if(etat2.time != etat1.time+1 or etat1.stock < etat2.stock ) :
				return 0
			Demand = Demand(etat1.time , action.prix)
			#coder une densité ayant son maximum en Demand 
			#retourner la probabilité 
			return 1/3

def Esp(etat , tab_V , action):
	i = etat.time
	P = np.array([ prob(etat , State(i + 1 , j) , action) for j in range(Stock_beg) ])
	V_r = np.array([ tab_V[i+1][j] + reward(State(j), action , ) for j in range(Stock_beg) ])
	return sum(np.dot(P , np.transpose(V_r)))

def argmax(f ,etat, tab_V , ensemble):
	result=ensemble[0] 
	for i in ensemble : 
		if (f(etat , tab_V , result)<f(etat , tab_V , i)):
			result = i
	return result 

def ChooseAction(etat , tab_V):
	return argmax(Esp , etat , tab_V , Table_actions)



def main():
	theta1 = 1/2
	theta2 = 1/2
	Nb_states = 24
	Stock_beg = 100
	pmax = 20 
	pmin = 10
	Table_actions =[]
	#Creation action par pas de k
	k = 10 
	pas = (pmax - pmin)/(k - 1)
	for i in range(k):
		Table_actions = np.append (Table_actions , Action(pmin + i*pas))
	#creation etats de 20h à 23h50 par pas de 10
	
	tab_V = np.array([])
	tab0 = [0 for i in range(Stock_beg - 1)]
	tab_d = tab0
	tab_d.append(0)
	tab0.append(1)
	tab_V = np.append(tab_V , tab0)
	i = 1 
	while(i<Nb_states):
		tab_V.append(0); 
		i+=1





















