#produit Client supposé défini 
#Segementation supposé effectuée 
import pandas as pd
import numpy as np  
import scipy.stats as stats
def_Filename = "data.csv"

def regression(Filename = def_Filename):
	L = pd.read_csv(Filename, sep=";")
#Suppression de ligne contenant la valeur 'NA'
	L = L.dropna()
# Nos arrays
	Y = np.array(L["demand"])
	Z_transp = np.array([L["time"] , L["price"]])
	Z = np.transpose(Z_transp)
	Z_diese = np.dot(Z_transp , Z)
	Z_diese = np.dot(np.linalg.inv(Z_diese), Z_transp )
	n=len(L)
	beta = np.dot(Z_diese , Y) 
	beta_t = beta[0]
	beta_p = beta[1]
	sigma2 = (1/(n-p)) * np.linalg.norm(temp)**2 
	return  (beta_t , beta_p , sigma2)

class Action : 
	#constructeur

	def __init__(self , prix):
		self.prix = prix

class Etat :
	#constructeur
    def __init__(self ,time , stock ):
        self.time = 0
        self.stock = 0


#une demande decroissante linéaire du prix et de la période 
"""
On se dit que plus il fait tard plus la demande est faible 
"""
"""
les parametres beta_t et beta_p sont à estimer à partir des données précédentes 
NB:regression linéaire 
"""
def Demand(time , price):
	try : 
		return beta_t * time_quant + beta_p + price 
	except : 
		return Stock_beg/Nb_states - 1
	
#alea Demand loc in demand above

def Prob(eta1 , action , etat2):
			if(etat2.time != etat1.time+1 or etat1.stock < etat2.stock ) :
				return 0
			Demand = Demand(etat1.time , action.prix)
			demand_here = etat1.stock - etat2.stock
			#return proba que Demand = etat1.stock - etat2.stock via le prix 
			return stats.norm.pdf( demand_here , loc = Demand , scale = sigma2 )
			#coder une densité ayant son maximum en Demand 
			#retourner la probabilité 
			#return 1/3

def reward(state1 , action ,state2):

	return theta1 * acton.price*(state1.stock - state2.stock) - theta2

def Esp(state , tab_V , action):
	i = etat.time
	P = np.array([ prob(etat , State(i + 1 , j) , action) for j in range(Stock_beg) ])
	V_r = np.array([ tab_V[i+1][j] + reward(state , State(j), action ) for j in range(Stock_beg) ])
	return sum(np.dot(P , np.transpose(V_r)))

def argmax(f ,etat, tab_V , ensemble):
	result=ensemble[0] 
	for i in ensemble : 
		if (f(etat , tab_V , result)<f(etat , tab_V , i)):
			result = i
	return result 

def ChooseAction(etat , tab_V):
	return argmax(Esp , etat , tab_V , Table_actions)



def main():
	theta1 = 1/2
	theta2 = 1/2
	Nb_states = 24
	Stock_beg = 100
	pmax = 20 
	pmin = 10
	Table_actions =[]
	#Creation action par pas de k
	k = 10 
	pas = (pmax - pmin)/(k - 1)
	for i in range(k):
		Table_actions.append(Action(pmin + i*pas))
	Table_actions = np.array (Table_actions )
	#creation etats de 20h à 23h50 par pas de 10
	
	tab_V = np.array([])
	tab0 = [0 for i in range(Stock_beg - 1)]
	tab_d = tab0
	tab_d.append(0)
	tab0.append(1)
	tab_V = np.zeros((Nb_states ,Stock_beg ))
	tab_V[0][Stock_beg - 1] = 1
	Print_tabAc(Table_actions)
	print(tab_V)


def Print_tabAc(Table_actions):
	print("-- " , end="")
	for i in Table_actions:
		print(i.prix , " -- ",end="")
	print()
	
main()

